// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for Fortran functions
class FortranFunctions {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FortranFunctions(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FortranFunctions.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// add function (Fortran)
  double add_f(
    double a,
    double b,
  ) {
    return _add_f(
      a,
      b,
    );
  }

  late final _add_fPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'add_f');
  late final _add_f = _add_fPtr.asFunction<double Function(double, double)>();

  /// sub function (Fortran)
  double sub_f(
    double a,
    double b,
  ) {
    return _sub_f(
      a,
      b,
    );
  }

  late final _sub_fPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'sub_f');
  late final _sub_f = _sub_fPtr.asFunction<double Function(double, double)>();

  /// div function (Fortran)
  double div_f(
    double a,
    double b,
  ) {
    return _div_f(
      a,
      b,
    );
  }

  late final _div_fPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'div_f');
  late final _div_f = _div_fPtr.asFunction<double Function(double, double)>();

  /// mul function (Fortran)
  double mul_f(
    double a,
    double b,
  ) {
    return _mul_f(
      a,
      b,
    );
  }

  late final _mul_fPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'mul_f');
  late final _mul_f = _mul_fPtr.asFunction<double Function(double, double)>();

  /// Объединение строк (Fortran)
  void concatenate(
    ffi.Pointer<ffi.Char> str1,
    ffi.Pointer<ffi.Char> str2,
    ffi.Pointer<ffi.Char> result_str,
  ) {
    return _concatenate(
      str1,
      str2,
      result_str,
    );
  }

  late final _concatenatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('concatenate');
  late final _concatenate = _concatenatePtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();
}
